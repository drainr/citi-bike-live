[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Citi Bikes",
    "section": "",
    "text": "The CitiBike data from New York City can provide alot of insight as to how a large portion of the population moves on a regular basis. I gathered this data from the CitiBikes in New York, specifically from the months of June and December 2024, as well as their feed of live data. The main goal of this project was to better understand how to work with data. Most users follow the general trends you see in other forms of transportation."
  },
  {
    "objectID": "heatmap.html",
    "href": "heatmap.html",
    "title": "heatmap",
    "section": "",
    "text": "library(shiny)\nlibrary(leaflet)\nlibrary(leaflet.extras)\nlibrary(leaflet.extras2)\nlibrary(httr)\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\n\nThe following object is masked from 'package:shiny':\n\n    validate\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\n\n\n# Fetch Citi Bike data function\nfetch_live_data &lt;- function() {\n  status_url &lt;- \"https://gbfs.citibikenyc.com/gbfs/en/station_status.json\"\n  info_url &lt;- \"https://gbfs.citibikenyc.com/gbfs/en/station_information.json\"\n  \n  # Fetch station status (availability of bikes and docks)\n  status_data &lt;- fromJSON(content(GET(status_url), \"text\", encoding = \"UTF-8\"))$data$stations\n  \n  # Fetch station info (lat/lon details)\n  info_data &lt;- fromJSON(content(GET(info_url), \"text\", encoding = \"UTF-8\"))$data$stations\n  \n  # Merge the two datasets on station ID\n  merged_data &lt;- merge(info_data, status_data, by = \"station_id\")\n  \n  # Convert to a data frame and return\n  merged_data &lt;- as.data.frame(merged_data)\n  return(merged_data)\n}\n\n# Shiny UI\nui &lt;- fluidPage(\n  titlePanel(\"Animated Bike Availability Heatmap with Enhanced Gradient\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\n        \"time\",\n        \"Select Time (Simulated):\",\n        min = 1,\n        max = 24,\n        value = 1,\n        step = 1,\n        animate = animationOptions(interval = 1000, loop = TRUE)\n      ),\n      actionButton(\"pause\", \"Pause\"),\n      actionButton(\"play\", \"Play\")\n    ),\n    mainPanel(\n      leafletOutput(\"map\", height = 600)\n    )\n  )\n)\n\n# Modified server function with enhanced visualization\nserver &lt;- function(input, output, session) {\n  # Fetch live data\n  stations &lt;- fetch_live_data()\n  \n  # Simulate time series data (hourly changes)\n  set.seed(123)\n  stations_time &lt;- stations %&gt;%\n    group_by(station_id) %&gt;%\n    mutate(hourly_bikes = list(sample(0:num_bikes_available, 24, replace = TRUE))) %&gt;%\n    tidyr::unnest(hourly_bikes) %&gt;%\n    mutate(hour = rep(1:24, length.out = n())) %&gt;%\n    ungroup()\n  \n  # Reactive data based on slider input\n  reactive_data &lt;- reactive({\n    stations_time %&gt;%\n      filter(hour == input$time) %&gt;%\n      select(station_id, lat, lon, weight = hourly_bikes)\n  })\n  \n  # Timer controls\n  auto_play &lt;- reactiveVal(TRUE)\n  \n  observeEvent(input$pause, {\n    auto_play(FALSE)\n  })\n  \n  observeEvent(input$play, {\n    auto_play(TRUE)\n  })\n  \n  # Auto-play slider\n  timer &lt;- reactiveTimer(1000)\n  \n  observe({\n    if (auto_play()) {\n      timer()\n      current_time &lt;- isolate(input$time)\n      new_time &lt;- ifelse(current_time &lt; 24, current_time + 1, 1)\n      updateSliderInput(session, \"time\", value = new_time)\n    }\n  })\n  \n  # Render Leaflet map\n  output$map &lt;- renderLeaflet({\n    leaflet() %&gt;%\n      addTiles() %&gt;%\n      addProviderTiles(providers$CartoDB.Positron) %&gt;%\n      setView(lng = -73.97, lat = 40.75, zoom = 13)\n  })\n  \n  # Observe time changes and update heatmap with enhanced gradient\n  observe({\n    data &lt;- reactive_data()\n    \n    # Enhanced scaling function with better distribution\n    data &lt;- data %&gt;%\n      mutate(\n        # Use cube root transformation for more balanced distribution\n        weight_transformed = weight^(1/3),\n        # Normalize the transformed values\n        weight_norm = (weight_transformed - min(weight_transformed)) / \n                     (max(weight_transformed) - min(weight_transformed)),\n        # Apply modified sigmoid for better spread\n        weight_norm = 1 / (1 + exp(-4 * (weight_norm - 0.4)))\n      )\n    \n    # Identify top busy stations\n    top_stations &lt;- data %&gt;% top_n(5, wt = weight)\n    \n    # Create a more balanced color palette with distinct steps\n    colors &lt;- colorRampPalette(c(\n      \"#000080\",  # Navy Blue (low)\n      \"#0000FF\",  # Blue\n      \"#00BFFF\",  # Deep Sky Blue\n      \"#00FF00\",  # Green\n      \"#FFFF00\",  # Yellow\n      \"#FFA500\",  # Orange\n      \"#FF4500\",  # Orange Red\n      \"#FF0000\"   # Red (high)\n    ))(12)\n    \n    leafletProxy(\"map\") %&gt;%\n      clearHeatmap() %&gt;%\n      clearMarkers() %&gt;%\n      addHeatmap(\n        lng = data$lon,\n        lat = data$lat,\n        intensity = data$weight_norm,\n        radius = 20,     # Increased radius\n        blur = 22,       # Adjusted blur\n        gradient = colors,\n        max = 1,\n        minOpacity = 0.35 # Slightly increased minimum opacity\n      ) %&gt;%\n      addPulseMarkers(\n        lng = top_stations$lon,\n        lat = top_stations$lat,\n        icon = makePulseIcon(color = \"red\", iconSize = 12),\n        popup = paste0(\n          \"Station ID: \", top_stations$station_id,\n          \"&lt;br&gt;Available Bikes: \", top_stations$weight\n        )\n      )\n  })\n}\n# Run the Shiny app\nshinyApp(ui, server)\n\nShiny applications not supported in static R Markdown documents"
  }
]